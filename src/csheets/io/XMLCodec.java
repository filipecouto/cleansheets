package csheets.io;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import org.dbunit.database.DatabaseConfig;
import org.dbunit.database.DatabaseConnection;
import org.dbunit.database.IDatabaseConnection;
import org.dbunit.dataset.IDataSet;
import org.dbunit.dataset.xml.FlatXmlDataSet;
import org.dbunit.dataset.xml.FlatXmlDataSetBuilder;
import org.dbunit.operation.DatabaseOperation;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Projections;

import csheets.core.Workbook;
import csheets.io.mapping.Hibernate;
import csheets.io.mapping.MappedWorkbook;
import csheets.io.versioning.VersionControllerCodec;
import csheets.io.versioning.VersionInfo;

/**
 * A codec for read and write XML files.
 * 
 * @author Filipe Silva & Rita Nogueira & Filipe Couto & Gil Castro (gil_1110484)
 */
public class XMLCodec implements Codec, VersionControllerCodec {

	/**
	 * Creates a new XML codec.
	 */
	public XMLCodec() {}

	@Override
	public Workbook read(InputStream stream) {
		try {
			// import from xml to database
			Class.forName("org.hsqldb.jdbcDriver");
			SessionFactory sessionFactory = Hibernate.getSessionFactory();
			Session session = sessionFactory.openSession();

			Connection jdbcConnection = DriverManager.getConnection("jdbc:hsqldb:mem:DBNAME", "sa", "");
			// jdbcConnection.prepareStatement("DROP SCHEMA PUBLIC CASCADE").execute();
			IDatabaseConnection connection = new DatabaseConnection(jdbcConnection);

			// script
			PreparedStatement preparedStatement;
			String statement = "drop table Cell if exists";
			preparedStatement = jdbcConnection.prepareStatement(statement);
			preparedStatement.execute();
			statement = "drop table Spreadsheet if exists";
			preparedStatement = jdbcConnection.prepareStatement(statement);
			preparedStatement.execute();
			statement = "drop table Workbook if exists";
			preparedStatement = jdbcConnection.prepareStatement(statement);
			preparedStatement.execute();
			statement = "create table Cell (id integer generated by default as identity (start with 1), address varbinary(255), backgroundColor varbinary(255), content varchar(255), font varbinary(255), foregroundColor varbinary(255), horizontalAlignment integer not null, verticalAlignment integer not null, spreadsheet_id integer not null, primary key (id))";
			preparedStatement = jdbcConnection.prepareStatement(statement);
			preparedStatement.execute();
			statement = "create table Spreadsheet (id integer generated by default as identity (start with 1), title varchar(255), workbook_id integer not null, primary key (id))";
			preparedStatement = jdbcConnection.prepareStatement(statement);
			preparedStatement.execute();
			statement = "create table Workbook (id integer generated by default as identity (start with 1), version timestamp, primary key (id))";
			preparedStatement = jdbcConnection.prepareStatement(statement);
			preparedStatement.execute();

			connection.getConfig().setProperty(DatabaseConfig.FEATURE_QUALIFIED_TABLE_NAMES, false);
			connection.getConfig().setProperty(DatabaseConfig.FEATURE_CASE_SENSITIVE_TABLE_NAMES, false);
			FlatXmlDataSetBuilder builder = new FlatXmlDataSetBuilder();
			builder.setCaseSensitiveTableNames(false);
			builder.setColumnSensing(true);
			builder.setDtdMetadata(false);
			IDataSet ds = builder.build(stream);
			DatabaseOperation.CLEAN_INSERT.execute(connection, ds);

			statement = "alter table Cell add constraint FK_41d8uvfegxcnvxrbqoi1cwjjs foreign key (spreadsheet_id) references Spreadsheet";
			preparedStatement = jdbcConnection.prepareStatement(statement);
			preparedStatement.execute();
			statement = "alter table Spreadsheet add constraint FK_bdm961fgbyp7vku1dybsvajat foreign key (workbook_id) references Workbook";
			preparedStatement = jdbcConnection.prepareStatement(statement);
			preparedStatement.execute();

			// gather the relevant information from the database and use it to load the workbook
			Query query = session.createQuery("from Workbook order by version desc");
			List list = query.list();
			final Workbook workbook = ((MappedWorkbook) list.get(0)).makeWorkbook();
			workbook.setVersionController(this);
			return workbook;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return new Workbook();
	}

	@Override
	public void write(Workbook workbook, OutputStream stream) throws IOException, TransformerException, ParserConfigurationException {
		workbook.setVersionController(this);
		// creates the database in memory
		Transaction transaction = null;
		SessionFactory sessionFactory = Hibernate.getSessionFactory();
		Session session = sessionFactory.openSession();
		transaction = session.beginTransaction();
		session.persist(new MappedWorkbook(workbook));
		transaction.commit();

		// exports the same database to an xml files
		try {
			Class driverClass = Class.forName("org.hsqldb.jdbcDriver");
			Connection jdbcConnection = DriverManager.getConnection("jdbc:hsqldb:mem:DBNAME", "sa", "");
			IDatabaseConnection connection = new DatabaseConnection(jdbcConnection);
			IDataSet fullSet = connection.createDataSet();
			FlatXmlDataSet.write(fullSet, stream);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Override
	public Workbook loadVersion(Object versionId, Workbook target) {
		System.out.println("XMLCodec.loadVersion(" + versionId + ", " + target + ")");
		SessionFactory sessionFactory = Hibernate.getSessionFactory();
		Session session = sessionFactory.openSession();
		final MappedWorkbook mappedWorkbook = (MappedWorkbook) session.get(MappedWorkbook.class, (int) versionId);
		final Workbook workbook = target == null ? mappedWorkbook.makeWorkbook() : mappedWorkbook.makeWorkbook(target);
		workbook.setVersionController(this);
		return workbook;
	}

	@Override
	public List<VersionInfo> getVersions() {
		try {
			Class.forName("org.hsqldb.jdbcDriver");
			SessionFactory sessionFactory = Hibernate.getSessionFactory();
			Session session = sessionFactory.openSession();
			List<VersionInfo> result = new ArrayList<>();
			List queryResult = session.createQuery(
					"SELECT book.id, book.version, count(sheet.id) FROM Workbook book, Spreadsheet sheet "
							+ "WHERE book.id=sheet.workbook GROUP BY book.id ORDER BY version DESC").list();
			// result = session.createCriteria(Workbook.class).addOrder(Order.desc("version"))
			// .setProjection(Projections.projectionList().add(Projections.property("id")).add(Projections.property("version"))).list();
			// for (int i = 0; i < result.size(); i++) {
			// System.out.print(i + "{ ");
			// for (int l = 0; l < ((Object[]) result.get(i)).length; l++) {
			// System.out.print(((Object[]) result.get(i))[l] + "; ");
			// }
			// System.out.print("}\n");
			// }
			for (Object item : queryResult) {
				Object[] version = (Object[]) item;
				result.add(new VersionInfo(version[0], null, (Timestamp) version[1], (int) (long) version[2], this));
			}
			return result;
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
}
